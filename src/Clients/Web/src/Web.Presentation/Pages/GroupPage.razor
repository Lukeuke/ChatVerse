@attribute [Authorize]
@page "/messages/g/{Id}"
@using Web.Application.Repositories.Chat
@using Web.Domain.DTOs
@using Web.Domain.Models
@using Web.Domain.Models.Chat
@using Newtonsoft.Json
@using Microsoft.AspNetCore.Components
@inject IChatRepository ChatRepository
@inject ICryptoClient CryptoClient
@inject IHttpClientFactory HttpClient

@if (MessagesList is null || MembersAndCount.Value.users is null)
{
    <div>
        Loading...
    </div>   
}
else
{
    <div class="d-flex w-100">
        <div class="w-75">
            @foreach (var message in MessagesList)
            {
                <div class="bg-black rounded p-2 m-2">
                    <div>
                        @message!.SenderFullName says: <span class="text-muted" style="font-size:calc(3px * 0.5vw);">@DateTimeOffset.FromUnixTimeSeconds((long)message.TimeStampOffset).ToString("g")</span>
                    </div>
                    <div>@message.Content</div>
                </div>
            }
        </div>
        
        <div class="w-25">
            <div class="position-sticky h-auto">
                <div>
                    Chat Members:
                    <div>
                        <ul>
                            @{
                                foreach (var user in MembersAndCount.Value.users)
                                {
                                    <li>@user</li>
                                }
                            }
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="d-flex align-items-center w-100">
        <div class="fixed-bottom w-50">
            <EditForm Model="@CreateMessage" OnValidSubmit="SendMessage">
                <input type="text" placeholder="Write message here..." class="form-control col-12" @bind="CreateMessage.Content"/>
                <input type="submit" class="form-control col-6 btn btn-primary" value="Send" />
            </EditForm>
        </div>
    </div>
}

@code {
    [Parameter]
    public string Id { get; set; }
    
    private List<ChatNameIdModel>? Chats { get; set; } = null;
    private List<IGetMessagesByGroupId_MessagesByGroupId_Nodes?>? MessagesList { get; set; } = new();
    private (List<string>? users, int Count)? MembersAndCount { get; set; } = new();
    private bool Loaded { get; set; } = false;
    private bool Subscribed { get; set; } = false;
    
    private CreateMessageDto CreateMessage { get; set; } = new ();
    
    protected override async Task OnInitializedAsync()
    {
        var jwt = await LocalStorage.GetItemAsStringAsync("token");

        var chats = await ChatRepository.GetChats(jwt.Replace("\"", ""));

        Chats = chats.ToList();
        await GetMessages();
        SubscribeToGroup();
        MembersAndCount = await GetMembersAndCount();
    }

    private async Task GetMessages()
    {
        if (!Loaded)
        {
            MessagesList = new();
            Loaded = true;
            var executeAsync = await CryptoClient.GetMessagesByGroupId.ExecuteAsync(Guid.Parse(Id!), 50);
            MessagesList = executeAsync.Data.MessagesByGroupId.Nodes.ToList();
            StateHasChanged();
        }
    }

    private async Task<(List<string> users, int Count)> GetMembersAndCount()
    {
        var users = new List<string>();
        
        var client = HttpClient.CreateClient("group");

        var jwt = client.DefaultRequestHeaders.Authorization;
        
        var json = await client.GetStringAsync($"group/{Id}");

        var members = JsonConvert.DeserializeObject<List<Member>>(json);

        foreach (var member in members!)
        {
            client = HttpClient.CreateClient("identity");
            client.DefaultRequestHeaders.Authorization = jwt;

            var username = await client.GetStringAsync($"auth/user/{member.Id}");
            
            var usernameModel = JsonConvert.DeserializeObject<UsernameModel>(username);
            
            users.Add(usernameModel!.Username);
        }

        return (users, members.Count);
    }
    
    private void SubscribeToGroup()
    {
        if (!Subscribed)
        {
            CryptoClient.GroupSubscribe.Watch(Id).Subscribe(r =>
            {
                var data = r.Data.MessageCreated;
                MessagesList!.Add(new GetMessagesByGroupId_MessagesByGroupId_Nodes_Message(data.Content, data.SenderFullName, data.TimeStampOffset));
            });
            Subscribed = true;
            StateHasChanged();
        }
    }

    private async Task SendMessage()
    {
        var result = await CryptoClient.CreateMessage.ExecuteAsync(new CreateMessageDtoInput
        {
            Content = CreateMessage.Content,
            GroupId = Guid.Parse(Id!)
        });

        if (result.Data.CreateMessage)
        {
            CreateMessage.Content = string.Empty;
            await GetMessages();
        }
    }
}